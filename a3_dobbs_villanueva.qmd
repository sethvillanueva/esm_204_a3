---
title: "a3_dobbs_villanueva"
format: 
  html:
    code-fold: true
    toc: true
    theme: darkly #flatly, superhero, lumen
knitr:
  opts_chunk: 
    code-line-numbers: true
editor: visual
jupyter: python3
---

## Assignment 3

```{r, results = 'hide', message=FALSE}

library(tidyverse)
library(here)
library(pracma)

```

```{r}
ev_dac_data <- read_csv(here('data', 'HW3_data.csv')) %>% janitor::clean_names()
```

### 1.

```{r}

demand_dac <- lm(price_dollars ~ q_dac, data = ev_dac_data) %>% summary()
demand_nondac <- lm(price_dollars ~ q_non_dac, data = ev_dac_data) %>% summary()

demand_dac
demand_nondac

```

$$\begin{aligned}
\\
&D_{DAC} = -6.611*Q_{EVs} + 116855 \\
&D_{nonDAC} = -2.731*Q_{EVs} + 158034 \\
\\
\end{aligned}$$

These differences in demand could be a result of a willingness to pay to avoid transportation pollution by

-   nonDACs have higher marginal benefit across all quantities than DACs (higher intercept and shallower slope)

### 2.

```{r}
mec_per_ev = 300 * 63

mec_per_ev
```

$$\begin{aligned}
\\
&MEC_{EV} = 18900 \\
\\
\end{aligned}$$

### 3.

```{r}

dac_demand_fn <- function(Q){
  P = (demand_dac$coefficients[2,1] * Q) + demand_dac$coefficients[1,1]
  return(P)
}

dac_demand_fn_q_from_p <- function(P){
  Q = ((1/demand_dac$coefficients[2,1]) * P) + (ddemand_dac$coefficients[1,1]]/(-demand_dac$coefficients[2,1]))
  return(Q)
}


nondac_demand_fn <- function(Q){
  P = (demand_nondac$coefficients[2,1] * Q) + demand_nondac$coefficients[1,1]
  return(P)
}

nondac_demand_fn_q_from_p <- function(P){
  Q = ((1/demand_nondac$coefficients[2,1]) * P) + (demand_nondac$coefficients[1,1]/(-demand_nondac$coefficients[2,1]))
  return(Q)
}

```

```{r}
# new agg demand attempt

ev_agg_demand <- data.frame(price_dollars = seq(from = 0, to = 165000, by = 1000))

ev_agg_demand <- ev_agg_demand %>% 
  mutate(q_dac_fitted = ifelse(dac_demand_fn_q_from_p(price_dollars)>0, dac_demand_fn_q_from_p(price_dollars), 0)) %>%    # fit dac regression results, but only for values greater than 0
  mutate(q_nondac_fitted = ifelse(nondac_demand_fn_q_from_p(price_dollars)>0, nondac_demand_fn_q_from_p(price_dollars), 0)) %>%     # fit nondac regression results, but only for values greater than 0
  mutate(q_agg = q_dac_fitted + q_nondac_fitted) %>%                  # calc aggregate demand values
  subset(q_agg > 0)             # filter out 0 values


ggplot(data = ev_agg_demand, aes(x = q_dac_fitted, y = price_dollars))  +
  geom_line() + 
  theme_bw()

ggplot(data = ev_agg_demand, aes(x = q_nondac_fitted, y = price_dollars))  +
  geom_line() + 
  theme_bw()

ggplot(data = ev_agg_demand, aes(x = q_agg, y = price_dollars))  +
  geom_line() + 
  theme_bw()


```

#### Making an aggregate demand function

We will make an aggregate demand function with two different line equations that are evaluated depending on whether Q is before or beyond the kink in the aggregate demand curve. The first line equation from (0, Q_kink) is simply D_nondac, though we must solve for the equation from Q_kink onward. We can do this with algebra, which involves first finding the Q of D_nondac at the equilibrium price, which gives us Q_kink. We then can solve for the horizontal sum below the y-intercept of D_dac, i.e. changing the y-intercept of D_nondac to equal the y-intercept of D_dac and horizontally summing (call this P'agg). From here, we can shift this curve by Q_kink, by taking P'agg(Q-Q_kink) to get the portion of the aggregate demand curve we will evaluate beyond Q_kink.

```{r}

q_kink = nondac_demand_fn_q_from_p(demand_dac$coefficients[1,1])

slope_agg = (demand_dac$coefficients[2,1]*demand_nondac$coefficients[2,1])/(demand_dac$coefficients[2,1] + demand_nondac$coefficients[2,1])

d_agg_beyond_kink_fn <- function(Q){
  price = (demand_dac$coefficients[1,1] - (slope_agg * q_kink)) +
             (slope_agg * Q)
  return(price)
}


agg_demand_fn <- function(Q){
  if (Q < q_kink) {
    price = nondac_demand_fn(Q)
  }
  if (Q >= q_kink) {
    price = d_agg_beyond_kink_fn(Q)
  }
  return(price)
}

```

```{r}

demand_less_price_no_int_fn <- function(Q){
  Z = agg_demand_fn(Q) - 50000
  return(Z)
}

q_star_no_int = fzero(fun = function(x) demand_less_price_no_int_fn(x), c(0,100000))$x
q_star_no_int
```

```{r}

supply_fn <- function(Q){
  P = (50000/q_star_no_int) * Q
}

```

For consumer surplus, we take the sum of the integral from \[0, Q_kink\] and the integral \[Q_kink, Q\*\], minus P\*xQ\*.

```{r}

cs = pracma::integral(fun = function(x) nondac_demand_fn(x), xmin = 0, xmax = q_kink) + pracma::integral(fun = function(x) d_agg_beyond_kink_fn(x), xmin = q_kink, xmax = q_star_no_int) - (q_star_no_int*50000)
cs

ps = (q_star_no_int*50000) / 2
ps

```

```{r}

env_cost_q_star_no_int = mec_per_ev * q_star_no_int
env_cost_q_star_no_int

```

```{r}

agg_demand_plot <- ggplot(data = ev_agg_demand, aes(x = q_agg, y = price_dollars)) +
  geom_point() +
  theme_bw()


agg_demand_plot
```

### 4.

```{r}

dac_q_star_no_int <- dac_demand_fn_q_from_p(50000)
dac_q_star_no_int


cs_dac_no_int = pracma::integral(fun = function(x) dac_demand_fn(x), xmin = 0, xmax = dac_q_star_no_int) - (dac_q_star_no_int*50000)
cs_dac_no_int

```

```{r}

nondac_q_star_no_int <- nondac_demand_fn_q_from_p(50000)
nondac_q_star_no_int


cs_nondac_no_int = pracma::integral(fun = function(x) nondac_demand_fn(x), xmin = 0, xmax = nondac_q_star_no_int) - (nondac_q_star_no_int*50000)
cs_nondac_no_int
```

```{r}
cs_dac_both <- cs_dac_no_int + cs_nondac_no_int

cs_dac_both
```

```{r}
cs_dac_percent = cs_dac_no_int/cs_dac_both
cs_dac_percent

cs_nondac_percent = cs_nondac_no_int/cs_dac_both
cs_nondac_percent

```

### 5.

Optimal tax is equal to the MEC(Q\*), and since MEC = 18900 as a constant, the optimal tax will be \$18900 per EV.

#### (a)

```{r}

supply_tax_fn <- function(Q){
  P = supply_fn(Q) + mec_per_ev
  return(P)
}


demand_less_price_tax_fn <- function(Q){
  Z = agg_demand_fn(Q) - supply_tax_fn(Q)
  return(Z)
}

q_star_tax = fzero(fun = function(x) demand_less_price_tax_fn(x), c(0,100000))$x
q_star_tax

```

#### (b)

```{r}

p_star_tax = agg_demand_fn(q_star_tax)
p_star_tax

```

```{r}

ev_agg_demand_tax <- ev_agg_demand %>% 
  mutate(q_msc_supply = ((q_star_tax/(p_star_tax - mec_per_ev))*price_dollars) - mec_per_ev)


```

#### (c)

```{r}

q_nondac_demand_tax = nondac_demand_fn_q_from_p(p_star_tax)
q_nondac_demand_tax

nondac_cs_tax = pracma::integral(fun = function(x) nondac_demand_fn(x), xmin = 0, xmax = q_nondac_demand_tax) - (q_nondac_demand_tax*p_star_tax)
nondac_cs_tax

```

#### (d)

```{r}

q_dac_demand_tax = dac_demand_fn_q_from_p(p_star_tax)
q_dac_demand_tax

dac_cs_tax = pracma::integral(fun = function(x) dac_demand_fn(x), xmin = 0, xmax = q_dac_demand_tax) - (q_dac_demand_tax*p_star_tax + mec_per_ev*q_star_tax)
dac_cs_tax

```

#### (e)

```{r}

ps_tax = (q_star_tax*(p_star_tax - mec_per_ev)) / 2
ps_tax

```

```{r}

ggplot()  +
  geom_line(data = ev_agg_demand, aes(x = q_dac_fitted, y = price_dollars)) + 
  geom_line(data = ev_agg_demand, aes(x = q_nondac_fitted, y = price_dollars))  +
  geom_line(data = ev_agg_demand, aes(x = q_agg, y = price_dollars))  +
  geom_line(data = ev_agg_demand_tax, aes(x = q_msc_supply, y = price_dollars))  +
  geom_line(data = ev_agg_demand_tax, aes(x = q_msc_supply, y = mec_per_ev))  +
  geom_line(data = ev_agg_demand_tax, aes(x = q_msc_supply, y = p_star_tax))  +
  xlim(0, 80000) +
  theme_bw()

```

#### (f)

```{r}

env_damage_tax = mec_per_ev * q_star_tax
env_damage_tax
```

#### (g)

```{r}

tax_revenue_tax = mec_per_ev * q_star_tax
tax_revenue_tax
```

### 6.

#### 

```{r}

dac_revenue_share_percent = dac_q_star_no_int / q_star_no_int
nondac_revenue_share_percent = nondac_q_star_no_int / q_star_no_int

dac_revenue_share_percent
nondac_revenue_share_percent

dac_revenue_share = tax_revenue_tax * dac_revenue_share_percent
nondac_revenue_share = tax_revenue_tax * nondac_revenue_share_percent

dac_revenue_share
nondac_revenue_share
```

#### (a)
